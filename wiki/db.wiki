<wiki:toc max_depth="4" />
下面所有的Table对象，是指在aot中定义的Table对象，它其实 是基于DataRow的.不要同DataTable相混扰。在ebf,可以通过Table对象 名加上 Table后缀来访问对应的DataTable,如Category表，可以通过CategoryTable来访问datatable对象。

===orm ===
ebf 通过自动生成强类型的datatable ，在  ado.net 的基础上构造了一个orm类的层


Table对象实例方法

||Insert||插入,可覆盖||
||Update||更新，可覆盖||
||Destory||删除，可覆盖||
||Write||插入或更新，可覆盖||
||DoInsert||插入||
||DoUpdat||更新||
||DoDestory||删除||
||DoWrite||插入或更新||
||ModifiedField||字段改变,可覆盖||
||ValidateField||验证字段，可覆盖||
||ValidateInsert||验证插入，可覆盖||
||ValidateDestory||验证删除，可覆盖||
||ValidateUpdate||验证更新，可覆盖||
||NewXXX||xxx是表名，允许传递kwargs||

Table对象也可以添加新的方法，业务逻辑可以尽量在这里处理

Table对象类方法

||Find||映射到Session.Find||
||FindById||映射到Session.FindById||
||UpdateById||同实例Update方法命名冲突,映射到Session.Update||
||UpdateAll||映射到Session.UpdateAll
||DeleteById||同DataRow.Delete方法命名冲突,Destory已用于 实例方法,映射到Session.Delete||
||DeleteAll||映射到Session.DeleteAll||
||Clear||映射到Session.Clear||
||Create|映射到Session.Create||



{{{

goods=Goods.Create(id='11',name='11')
goods.Insert()


Goods.UpdateById(goods.recId,id='12',name='12')

Goods.DeleteById(goods.recId)



}}}

*静态方法可能会引发冲突 ，比方 说删除了一个相应的记录但DataRow还是存在，或是更新了一个行但数据行并不会反映变化*

====Table对象对应的DataTable ====
DataTable由于从TypedDataTableBase继承，因此可以 直接 对datatable进行迭代 
{{{

for goods in Session.Find[Goods]():
  print goods.id
}}}

DataTable方法

||Count||相当于DataTable.Rows.Count||
||this|相当 于DataTable.Rows 数组调用||
||SubmitChanges||全部递交||


===Session ===
||Create||创建新记录||
||FindById||根据主键||
||Find||查询||
||Clear||清除||
||Delete||根据id删除||
||DeleteAll||根据conditions条件删除||
||Update||根据id和kwargs更新单条记录||
||UpdateAll||按条件更新||
||ClearAll||清除全部||

除了 ClearAll等一些特定的方法，大部分Session的方法均需要你传递类型参数 ，需要简便的话直接调用 Table对象的静态方法 

====创建新记录===

{{{

category=Session.Create[Category](id=id,name=name)
category.Insert()


}}}

====查询记录===

根据id查找，每个表均有一个recid identity int64字段,不存在将触发RecordNotFoundException

{{{

category=Session.FindById[Category](9)

当传入一个列表时返回一个数组

categories=Session.FindById[Category]([1,2,3,4,5])
for categoy in categories:
  print category.name

}}}


返回强类型datatable,可传递conditions,limit,offset,joins,from,group,select,order,params 模拟ActiveRecord.Find

{{{

result=Session.Find[Goods](conditons='id like @id',params={'@id':'0702%'})

for goods in result:
  print goods.id,goods.name

}}}

==== 更新记录 ====
{{{
goods.Update()
}}}



====创建新记录直接通过dataTable====
{{{
categories=CategoryTable()
category=categories.NewCategory(id='a',name='test') # 或者category.NewRow()

cateogries.Rows.Add(category) #可选，Insert方法会自动执行
category.Insert()  

}}}



=== sql ===

如果需要直接操作sql,请通过SqlHelper

||函数名称||作用||
||TtsBegin||开始事务||
||TtsCommit||提交事务||
||TtsRollback||回退事务||
||ExecuteNonQuery||执行sql 查询，返回int||
||ExecuteDataTable||查询指定name的数据表，name是aot中定义的table名||
||Insert||传递DataRow[]数组||
||Update||传递DataRow[]数组||
||Delete||传递DataRow[]数组||
||SubmitChanges||传递DataTable或DataSet||

这些方法由SqlHelper提供,ebf 将常用的方法注册到ironpython，你可以直接用函数名调用而不是SqlHelper.xxx,一些扩展的方法当前必须通过SqlHelper前缀调用，如SqlHelper.ExecuteNonQuery('delete from table1 where field1=@field1',field1='test') *①这是由于ironpython注册函数时的一些不足造成的*



=== 批量提交 ===

1. 创建新行，加入到datatable Rows集合或更新行，或删除行

2. 调用datatable SubmitChanges

*批量提交跳过Insert,Update,Delete过程*


①对于kwargs,c#需在kwargs参数前施加 ParamDictionary attribute,但ScriptScope.SetVariable时，无法将这个attribute施加在Func类型上