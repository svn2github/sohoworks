<wiki:toc max_depth="5" />
下面所有的Table对象，是指在aot中定义的Table对象，它其实 是基于DataRow的.不要同DataTable相混扰。在ebf,可以通过Table对象 名加上 Table后缀来访问对应的DataTable,如Category表，可以通过CategoryTable来访问datatable对象。

===orm ===
ebf 通过自动生成强类型的datatable ，在  ado.net 的基础上构造了一个orm类的层


====Table对象实例方法====

||Insert||插入,可覆盖||
||Update||更新，可覆盖||
||Destory||删除，可覆盖||
||Write||插入或更新，可覆盖||
||DoInsert||插入||
||DoUpdat||更新||
||DoDestory||删除||
||DoWrite||插入或更新||
||ModifiedField||字段改变,可覆盖||
||ValidateField||验证字段，可覆盖||
||ValidateInsert||验证插入，可覆盖||
||ValidateDestory||验证删除，可覆盖||
||ValidateUpdate||验证更新，可覆盖||
||NewXXX||xxx是表名，允许传递kwargs||

Table对象也可以添加新的方法，业务逻辑可以尽量在这里处理

对于 ModifiedField,Validatefield,InitValue等方法 ，存在着是ui调用还是table对象自动调用的问题。ui调用即重载 控件的的validating,validated方法 。在新增 ，保存，删除时调用

而table对象 自动调用则是通过Table的NewRow,ColumnChanging,ColumnChanged等事件。两者更有优点和缺点，前者需要更多的基础代码，后者要求的代码少，但面积太广，比方有时不想让其触发了，或是在修改事件中再修改会导致重复触发的。从最终操作上来看，前者更倒是更加简单一些。


====Table对象类方法====

||Find||映射到Session.Find||
||FindById||映射到Session.FindById||
||UpdateById||同实例Update方法命名冲突,映射到Session.Update||
||UpdateAll||映射到Session.UpdateAll
||DeleteById||同DataRow.Delete方法命名冲突,Destory已用于 实例方法,映射到Session.Delete||
||DeleteAll||映射到Session.DeleteAll||
||Clear||映射到Session.Clear||
||Create||映射到Session.Create||

==== samples====

{{{

goods=Goods.Create(id='11',name='11')
goods.Insert()


Goods.UpdateById(goods.recId,id='12',name='12')

Goods.DeleteById(goods.recId)



}}}

*静态方法可能会引发冲突 ，比方 说删除了一个相应的记录但DataRow还是存在，或是更新了一个行但数据行并不会反映变化*

==== Table对象对应的DataTable ====
DataTable由于从TypedDataTableBase继承，因此可以 直接 对datatable进行迭代 
{{{

for goods in Session.Find[Goods]():
  print goods.id
}}}

=====DataTable方法=====

||Count||相当于DataTable.Rows.Count||
||this|相当 于DataTable.Rows 数组调用||
||SubmitChanges||全部递交||
||Add||DataTable.Rows.Add(row)||
||Remove||DataTable.Rows.Remove||


===Session ===
||Begin||SqlHelper.TTSBegin||
||Commit||SqlHelper.TTSCommit||
||About||SqlHelper.TTSAbout||
||Create||创建新记录||
||FindById||根据主键||
||Find||查询||
||Clear||清除||
||Delete||根据id删除||
||DeleteAll||根据conditions条件删除||
||Update||根据id和kwargs更新单条记录||
||UpdateAll||按条件更新||
||ClearAll||清除全部||

除了 ClearAll等一些特定的方法，大部分Session的方法均需要你传递类型参数(由于ironpython生成的类型名有问题，而ClrTypeMetaclass在解决这个 问题时又带来的新问题，所以这里表参数直接通过字符串传递) ，需要简便的话直接调用 Table对象的静态方法 

====创建新记录===

{{{

category=Session.Create("Category",id=id,name=name)
category.Insert()


}}}

====查询记录===

根据id查找，每个表均有一个recid identity int64字段,不存在将触发RecordNotFoundException

{{{

category=Session.FindById("Category",9)

当传入一个列表时返回一个数组

categories=Session.FindById('Category',[1,2,3,4,5])
for categoy in categories:
  print category.name

}}}


返回强类型datatable,可传递conditions,limit,offset,joins,from,group,select,order,params 模拟ActiveRecord.Find

{{{

result=Session.Find('Goods',conditons='id like @id',params={'@id':'0702%'})

for goods in result:
  print goods.id,goods.name

}}}

==== 更新记录 ====
{{{
goods.Update()
}}}



====创建新记录直接通过dataTable====
{{{
categories=CategoryTable()
category=categories.NewCategory(id='a',name='test') # 或者category.NewRow()

cateogries.Rows.Add(category) #可选，Insert方法会自动执行
category.Insert()  

}}}



=== sql ===

如果需要直接操作sql,请通过SqlHelper

||函数名称||作用||
||TTSBegin||开始事务||
||TTSCommit||提交事务||
||TTSAbout||回退事务||
||ExecuteNonQuery||执行sql 查询，返回int||
||ExecuteDataTable||查询指定name的数据表，name是aot中定义的table名||
||Insert||传递DataRow[]数组||
||Update||传递DataRow[]数组||
||Delete||传递DataRow[]数组||
||SubmitChanges||传递DataTable或DataSet||

这些方法由SqlHelper提供,ebf 将常用的方法注册到ironpython，你可以直接用函数名调用而不是SqlHelper.xxx,一些扩展的方法当前必须通过SqlHelper前缀调用，如SqlHelper.ExecuteNonQuery('delete from table1 where field1=@field1',field1='test') *①这是由于ironpython注册函数时的一些不足造成的*



=== 批量提交 ===

1. 创建新行，加入到datatable Rows集合或更新行，或删除行

2. 调用datatable SubmitChanges

*批量提交跳过Insert,Update,Delete过程*


①对于kwargs,c#需在kwargs参数前施加 ParamDictionary attribute,但ScriptScope.SetVariable时，无法将这个attribute施加在Func类型上